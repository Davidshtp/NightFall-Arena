# player.gd

extends CharacterBody2D

@export var speed: float = 150.0
@export var fire_rate: float = 0.5
@export var bullet_scene: PackedScene
@export var max_health: int = 100
@export var game_over_scene: PackedScene # Escena de Game Over
@onready var animated_sprite: AnimatedSprite2D = $AnimatedSprite2D
@onready var health_bar: ProgressBar = $HealthBarContainer/HealthBar

var last_direction: Vector2 = Vector2.RIGHT
var current_health: int
var can_take_damage: bool = true # Para implementar invulnerabilidad temporal (i-frames)
var is_dead: bool = false

# Estadísticas del juego
var survival_time: float = 0.0
var kill_count: int = 0

func _ready():
	current_health = max_health
	animated_sprite.play("idle")
	
	# Agregar el jugador al grupo "player" si no está
	if not is_in_group("player"):
		add_to_group("player")
	
	# Actualizar barra de vida inicial
	if health_bar:
		health_bar.update_health(current_health, max_health)

func _process(delta):
	# Contar el tiempo de supervivencia
	survival_time += delta

func _physics_process(_delta):
	# Obtener input del jugador
	var input_vector = Vector2.ZERO
	input_vector.x = Input.get_axis("ui_left", "ui_right")
	input_vector.y = Input.get_axis("ui_up", "ui_down")
	
	# Normalizar para evitar movimiento diagonal más rápido
	if input_vector.length() > 0:
		input_vector = input_vector.normalized()
		last_direction = input_vector
	
	# Aplicar velocidad
	velocity = input_vector * speed
	
	# Manejar animaciones de movimiento
	if velocity.length() > 0:
		animated_sprite.play("run")
		# Voltear sprite según dirección
		if velocity.x > 0:
			animated_sprite.flip_h = false
		elif velocity.x < 0:
			animated_sprite.flip_h = true
	else:
		# Solo volver a idle si no está en animación de daño
		if animated_sprite.animation != "receivedamage":
			animated_sprite.play("idle")
	
	# Mover el jugador
	move_and_slide()

# Función de ataque del jugador
func _on_fire_timer_timeout():
	if bullet_scene == null:
		return
	
	# Calcular dirección hacia el cursor
	var mouse_pos = get_global_mouse_position()
	var shoot_direction = (mouse_pos - global_position).normalized()
	
	# Disparar la bala hacia el cursor
	var bullet = bullet_scene.instantiate()
	get_parent().add_child(bullet)
	bullet.global_position = global_position
	bullet.set_direction(shoot_direction)

# Función llamada por los enemigos al colisionar
func take_damage(amount: int):
	if not can_take_damage or is_dead:
		return
		
	current_health -= amount
	current_health = max(0, current_health) # No permitir valores negativos
	
	# Actualizar barra de vida
	if health_bar:
		health_bar.update_health(current_health, max_health)
	
	print("Player HP: ", current_health, "/", max_health)
	
	if current_health <= 0:
		die()
	else:
		# 1. Iniciar invulnerabilidad temporal
		can_take_damage = false
		if has_node("TimerIFrames"):
			$TimerIFrames.start()
		else:
			# Si no existe el timer, crear uno temporal
			await get_tree().create_timer(1.0).timeout
			can_take_damage = true
		
		# 2. Ejecutar animación de daño
		if animated_sprite.sprite_frames.has_animation("receivedamage"):
			animated_sprite.play("receivedamage")
			# El _physics_process se encargará de volver a la animación correcta

# Conectada a la señal body_entered del nodo Hurtbox
func _on_hurtbox_body_entered(body):
	# Aseguramos que solo reaccione a los enemigos
	if is_dead:
		return
	
	is_dead = true
	print("¡Player murió! Mostrando Game Over...")
	
	# Detener movimiento
	velocity = Vector2.ZERO
	set_physics_process(false)
	
	# Reproducir animación de muerte si existe
	if animated_sprite.sprite_frames.has_animation("die"):
		animated_sprite.play("die")
		# Esperar a que termine la animación
		await animated_sprite.animation_finished
	else:
		# Si no hay animación de muerte, esperar un poco
		await get_tree().create_timer(0.5).timeout
	
	# Mostrar pantalla de Game Over
	show_game_over()

func show_game_over():
	"""Muestra la pantalla de Game Over con las estadísticas"""
	print("Llamando a show_game_over()...")
	
	if game_over_scene == null:
		print("ERROR: game_over_scene no está asignada en el inspector!")
		print("Por favor, asigna scenes/ui/GameOver.tscn en el inspector del Player")
		# Intentar cargar la escena manualmente
		game_over_scene = load("res://scenes/ui/GameOver.tscn")
		if game_over_scene == null:
			print("ERROR: No se pudo cargar GameOver.tscn")
			return
	
	# Instanciar la escena de Game Over
	var game_over = game_over_scene.instantiate()
	
	# Pasar las estadísticas
	if game_over.has_method("set_stats"):
		game_over.set_stats(survival_time, kill_count)
	
	print("Añadiendo Game Over al árbol de escena...")
	# Añadir al árbol de escena
	get_tree().root.add_child(game_over)
	print("Game Over añadido exitosamente!")

func add_kill():
	"""Incrementa el contador de kills (llamado por los enemigos al morir)"""
	kill_count += 1
	print("Kills: ", kill_count)
func add_kill():
	"""Incrementa el contador de kills (llamado por los enemigos al morir)"""
	kill_count += 1
	print("Kills: ", kill_count)
	velocity = Vector2.ZERO
	
	# 1. Ejecutar animación de muerte si existe
	if animated_sprite.sprite_frames.has_animation("die"):
		animated_sprite.play("die")
		await animated_sprite.animation_finished
	else:
		# Si no hay animación, mostrar idle y esperar un momento
		animated_sprite.play("idle")
		await get_tree().create_timer(1.0).timeout
	
	# 2. Detener el juego, mostrar Game Over, etc.
	print("Game Over!")
	get_tree().paused = true
	# queue_free() # Opcional: descomentar si quieres destruir al jugador
